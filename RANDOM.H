// Author  : Keith H. Duggar
// Date    : 2001.01.29
// Name    : random.h
// Purpose : This header provides the definition for class Random.  Class Random
//           provides an interface for generating random numbers.  In its current
//           implementation it uses a shuffled prime modulus multiplicative
//           linear congruential generator (PMMLCG).  It uses the following
//           constants recommended by Park and Miller (1988):
//               modulus    = 2^31 - 1
//               multiplier = 69621
//           The shuffle pool contains 128 integers.
//
//			 Random is implemented as a singleton meaning there is only one copy
//           of Random.  Clients access it through the Instance function.
//
////////////////////////////////////////////////////////////////////////////////
/*345678901234567890123456789012345678901234567890123456789012345678901234567890
000000000100000000020000000003000000000400000000050000000006000000000700000000*/
////////////////////////////////////////////////////////////////////////////////

#ifndef RANDOM_H
#define RANDOM_H

class Random {
	public:
		static Random*  instance(); //Access the single copy of Random
	private:
		static Random* _instance;   //The single copy of Random
	protected:
		Random();                   //Prevent client construction

	public:
		int    nextInt    (void);  //Return an integer deviate in the interval [0  , maxint] (closed)
		double nextFloat  (void);  //Return a  uniform deviate in the interval [0.0,    1.0] (closed)
		double nextAngle  (void);  //Return a  uniform deviate in the interval [0.0,    1.0) (semi-open)
		double nextSlice  (void);  //Return a  uniform deviate in the interval (0.0,    1.0) (open)
		int	   nextBin    (double, int);   
								   //Return a binomial deviate with specified probability
								   //parameter and number of trials
		int	   nextPoisson(double);	   
								   //Return poisson with specified rate

	public:
        int    getMaxInt  (void);
		double getMaxAngle(void);
		double getMaxSlice(void);
		double getMinSlice(void);

	private:
        int    nextInt    (int) ;  //Given the kth integer return the (k+1)th integer using PMMLCG.
		void   initPool   (void);  //Initialize the integer pool.
		double gammln     (double);//log gamma function.

	private:
		int PoissonLow    (double);
		int PoissonInver  (double);
		int PoissonRatioUniforms(double);
		double LnFac(int n);

	private:
        static int    const maxInt    ;  //0x7FFFFFFD (2^31 - 1)
		static int    const modulus   ;  //0x7FFFFFFF (2^31 - 1)
        static int    const multiplier;  //69621
        static int    const quotient  ;  //30845
        static int    const remainder ;  //23902
		static int    const poolSize  ;  //128
		static double const maxAngle  ;  //
		static double const maxSlice  ;  //
		static double const minSlice  ;  //
		static int          pool[]    ;  //The integer shuffle pool.

		int       prevGenInt;  //Previous integer generated by PMMLCG
        int       prevOutInt;  //Previous shuffled integer
};

/////////////////////////////////////////////////////////////////////////////////
//Calculate the next integer given an integer
inline int Random::nextInt(int prevGenInt) {

	int nextInt;

	nextInt  = multiplier * (prevGenInt % quotient);  //Calculate the next integer from
	nextInt -= remainder  * (prevGenInt / quotient);  //previously generated integer using
	if(nextInt < 1) nextInt += modulus;               //Schrage's method (1983)

	return nextInt;
}
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//Return the next shuffled integer from the integer pool and replace it by a
//newly generated integer
inline int Random::nextInt(void) {

	int index;
	int nextInt;

	nextInt  = multiplier * (prevGenInt % quotient);  //Calculate the next integer from
	nextInt -= remainder  * (prevGenInt / quotient);  //previously generated integer using
	if(nextInt < 1) nextInt += modulus;               //Schrage's method (1983)
	
	index       = prevOutInt % poolSize;  //Calculate the index from the previously returned random integer
	prevOutInt  = pool[index];            //Extract the new shuffled integer
    pool[index] = nextInt;                //Replace with the newly generated integer
	prevGenInt  = nextInt;                //Generate and store the next integer

	return (prevOutInt - 1);              //Map to interval [0, maxint] (inclusive)
}
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//Return a uniform deviate by normalizing nextInt() to the appropriate interval
inline double Random::nextFloat(void) {return (double(nextInt())     / double(maxInt))    ;}
inline double Random::nextAngle(void) {return (double(nextInt())     / double(maxInt + 1));}
inline double Random::nextSlice(void) {return (double(nextInt() + 1) / double(maxInt + 2));}
/////////////////////////////////////////////////////////////////////////////////


#endif //End RandomH
